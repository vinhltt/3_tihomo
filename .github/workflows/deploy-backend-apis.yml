name: Deploy Backend APIs

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      services:
        description: 'Specific services to deploy (comma-separated: identity-api,corefinance-api,excel-api,ocelot-gateway) or "all"'
        required: false
        default: 'all'
        type: string
      force_rebuild:
        description: 'Force rebuild images'
        required: false
        default: false
        type: boolean
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'development'
        type: string
      services:
        description: 'Specific services to deploy (comma-separated: identity-api,corefinance-api,excel-api,ocelot-gateway) or "all"'
        required: false
        default: 'all'
        type: string
      force_rebuild:
        description: 'Force rebuild images'
        required: false
        default: false
        type: boolean

concurrency:
  group: tihomo-backend-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  # Build and test backend services
  build-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      matrix:
        service: [identity-api, corefinance-api, excel-api, ocelot-gateway]
    
    steps:
      - name: "[1/8] Checkout code"
        uses: actions/checkout@v4

      - name: "[2/8] Setup .NET"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: "[3/8] Restore dependencies"
        run: |
          cd src/be
          # Clear any cached packages and restore
          dotnet clean
          dotnet restore --force --no-cache

      - name: "[4/8] Build solution"
        run: |
          cd src/be
          dotnet build --no-restore --configuration Release

      - name: "[5/8] Run tests"
        run: |
          cd src/be
          # Run tests for the specific service if test project exists
          case "${{ matrix.service }}" in
            identity-api)
              if [ -d "Identity.Tests" ]; then
                dotnet test Identity.Tests --no-build --configuration Release --verbosity normal
              else
                echo "No tests found for Identity service"
              fi
              ;;
            corefinance-api)
              if [ -d "CoreFinance.Tests" ]; then
                dotnet test CoreFinance.Tests --no-build --configuration Release --verbosity normal
              else
                echo "No tests found for CoreFinance service"
              fi
              ;;
            excel-api)
              if [ -d "ExcelApi.Tests" ]; then
                dotnet test ExcelApi.Tests --no-build --configuration Release --verbosity normal
              else
                echo "No tests found for ExcelApi service"
              fi
              ;;
            ocelot-gateway)
              if [ -d "Ocelot.Gateway.Tests" ]; then
                dotnet test Ocelot.Gateway.Tests --no-build --configuration Release --verbosity normal
              else
                echo "No tests found for Ocelot Gateway service"
              fi
              ;;
          esac

      # TEMPORARILY DISABLED: GHCR build/push due to network timeout issues
      # Will deploy using source code directly via docker-compose.services.yml
      - name: "[6/6] Verify Docker build locally (without push)"
        if: github.event_name != 'pull_request'
        run: |
          cd src/be
          echo "✅ Skipping GHCR build/push due to network timeout"
          echo "✅ Will deploy using docker-compose.services.yml with source code"
          echo "✅ Service ${{ matrix.service }} build test completed successfully"

  # Deploy to TrueNAS
  deploy:
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch')
    needs: build-and-test
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    timeout-minutes: 20

    steps:
      - name: "[1/6] Checkout code"
        uses: actions/checkout@v4

      - name: "[2/6] Setup environment variables"
        run: |
          CLEAN_ENV=$(echo "${{ inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
          echo "TRUENAS_DEPLOY_DIR=${{ vars.DEPLOY_PATH_ON_TRUENAS }}/deploy_${GITHUB_REF_NAME}" >> $GITHUB_ENV
          echo "COMPOSE_PROJECT_NAME=tihomo_${CLEAN_ENV}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${CLEAN_ENV}" >> $GITHUB_ENV
          
          # Parse services to deploy
          SERVICES="${{ inputs.services || 'all' }}"
          if [ "$SERVICES" = "all" ]; then
            SERVICES="identity-api,corefinance-api,excel-api,ocelot-gateway"
          fi
          echo "SERVICES_TO_DEPLOY=${SERVICES}" >> $GITHUB_ENV
          
          echo "[INFO] Deploy directory: ${{ vars.DEPLOY_PATH_ON_TRUENAS }}/deploy_${GITHUB_REF_NAME}"
          echo "[INFO] Project name: tihomo_${CLEAN_ENV}"
          echo "[INFO] Deploying Backend APIs: ${SERVICES}"

      - name: "[3/6] Setup SSH and Cloudflared"
        run: |
          sudo wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O /usr/local/bin/cloudflared
          sudo chmod +x /usr/local/bin/cloudflared
          
          mkdir -p "$HOME/.ssh"
          echo "Host truenas-cf-tunnel
            HostName ${{ secrets.TRUENAS_SSH_HOSTNAME_THROUGH_CLOUDFLARED }}
            ProxyCommand cloudflared access ssh --hostname %h
            User ${{ secrets.TRUENAS_USER }}
            StrictHostKeyChecking accept-new
            ServerAliveInterval 60
            ServerAliveCountMax 10
            TCPKeepAlive yes" > "$HOME/.ssh/config"
          chmod 600 "$HOME/.ssh/config"

      - name: "[4/7] Add SSH key"
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.TRUENAS_SSH_PRIVATE_KEY }}

      - name: "[5/7] Sync deployment files and source code to server"
        run: |
          echo "[SYNC] Syncing deployment files and backend source code to TrueNAS..."
          
          # Create remote directory
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10 -F "$HOME/.ssh/config" truenas-cf-tunnel "mkdir -p ${{ env.TRUENAS_DEPLOY_DIR }}"
          
          # Copy essential files
          echo "[SYNC] Copying docker-compose.services.yml..."
          scp -F "$HOME/.ssh/config" docker-compose.services.yml truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          
          # Create comprehensive .env file directly using echo statements (GitHub Actions compatible)
          echo "[ENV] Creating comprehensive .env file using GitHub secrets..."
          
          # Create .env file using echo statements to ensure proper GitHub Actions interpolation
          echo "# TiHoMo Backend Environment Configuration" > /tmp/backend.env
          echo "# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> /tmp/backend.env
          echo "" >> /tmp/backend.env
          echo "# Project Configuration" >> /tmp/backend.env
          echo "COMPOSE_PROJECT_NAME=${{ env.COMPOSE_PROJECT_NAME }}" >> /tmp/backend.env
          echo "ENVIRONMENT=${{ env.ENVIRONMENT }}" >> /tmp/backend.env
          echo "" >> /tmp/backend.env
          echo "# Application Ports" >> /tmp/backend.env
          echo "FRONTEND_PORT=${{ vars.FRONTEND_PORT || '3500' }}" >> /tmp/backend.env
          echo "GATEWAY_PORT=${{ vars.GATEWAY_PORT || '5800' }}" >> /tmp/backend.env
          echo "" >> /tmp/backend.env
          echo "# Authentication & Security" >> /tmp/backend.env
          echo "JWT_SECRET_KEY='${{ secrets.JWT_SECRET_KEY }}'" >> /tmp/backend.env
          echo "JWT_ISSUER='${{ secrets.JWT_ISSUER || 'tihomo' }}'" >> /tmp/backend.env
          echo "JWT_AUDIENCE_IDENTITY_API='${{ secrets.JWT_AUDIENCE_IDENTITY_API || 'identity-api' }}'" >> /tmp/backend.env
          echo "JWT_AUDIENCE_COREFINANCE_API='${{ secrets.JWT_AUDIENCE_COREFINANCE_API || 'corefinance-api' }}'" >> /tmp/backend.env
          echo "JWT_AUDIENCE_OCELOT_GATEWAY='${{ secrets.JWT_AUDIENCE_OCELOT_GATEWAY || 'ocelot-gateway' }}'" >> /tmp/backend.env
          echo "" >> /tmp/backend.env
          echo "# OAuth Configuration" >> /tmp/backend.env
          echo "APP_PUBLIC_GOOGLE_CLIENT_ID='${{ secrets.APP_PUBLIC_GOOGLE_CLIENT_ID }}'" >> /tmp/backend.env
          echo "FACEBOOK_APP_ID='${{ secrets.FACEBOOK_APP_ID }}'" >> /tmp/backend.env
          echo "FACEBOOK_APP_SECRET='${{ secrets.FACEBOOK_APP_SECRET }}'" >> /tmp/backend.env
          echo "NUXT_PUBLIC_FACEBOOK_APP_ID='${{ secrets.FACEBOOK_APP_ID }}'" >> /tmp/backend.env
          echo "" >> /tmp/backend.env
          echo "# Frontend Configuration" >> /tmp/backend.env
          echo "FRONTEND_BASE_URL='${{ vars.FRONTEND_BASE_URL || 'http://localhost:3500' }}'" >> /tmp/backend.env
          echo "PUBLIC_API_BASE_URL='${{ vars.PUBLIC_API_BASE_URL || 'http://localhost:5800' }}'" >> /tmp/backend.env
          echo "" >> /tmp/backend.env
          echo "# Infrastructure" >> /tmp/backend.env
          echo "REDIS_PASSWORD='${{ secrets.REDIS_PASSWORD }}'" >> /tmp/backend.env
          echo "RABBITMQ_PASSWORD='${{ secrets.RABBITMQ_PASSWORD }}'" >> /tmp/backend.env
          echo "" >> /tmp/backend.env
          echo "# Database Configuration" >> /tmp/backend.env
          echo "POSTGRES_SUPER_PASSWORD='${{ secrets.POSTGRES_SUPER_PASSWORD }}'" >> /tmp/backend.env
          echo "IDENTITY_DB_PASSWORD='${{ secrets.IDENTITY_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}'" >> /tmp/backend.env  
          echo "COREFINANCE_DB_PASSWORD='${{ secrets.COREFINANCE_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}'" >> /tmp/backend.env
          echo "" >> /tmp/backend.env
          echo "# Deployment Information" >> /tmp/backend.env
          echo "DEPLOY_BRANCH=${{ github.ref_name }}" >> /tmp/backend.env
          echo "DEPLOY_COMMIT=${{ github.sha }}" >> /tmp/backend.env
          echo "DEPLOY_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> /tmp/backend.env
          
          # Debug: Show first few lines of created .env file
          echo "[DEBUG] First 10 lines of created .env file:"
          head -10 /tmp/backend.env
          
          echo "[DEBUG] Critical variables check in local .env:"
          grep -E "^(JWT_SECRET_KEY|REDIS_PASSWORD|RABBITMQ_PASSWORD)=" /tmp/backend.env || echo "[WARNING] Some critical variables missing in local file"
          
          # Copy .env file to server
          echo "[UPLOAD] Uploading .env file to server..."
          scp -F "$HOME/.ssh/config" /tmp/backend.env truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/.env
          
          # Validate critical variables on server
          echo "[VALIDATION] Validating critical environment variables..."
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10 -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
          cd ${{ env.TRUENAS_DEPLOY_DIR }}
          
          echo "[VALIDATION] Checking critical backend variables..."
          
          # Validate critical variables
          critical_vars="JWT_SECRET_KEY REDIS_PASSWORD RABBITMQ_PASSWORD"
          missing_vars=""
          
          for var in $critical_vars; do
            if ! grep -q "^${var}=" .env || [ "$(grep "^${var}=" .env | cut -d'=' -f2 | tr -d "'")" = "" ]; then
              missing_vars="$missing_vars $var"
            fi
          done
          
          if [ -n "$missing_vars" ]; then
            echo "[ERROR] Missing critical backend variables:$missing_vars"
            exit 1
          else
            echo "[SUCCESS] All critical backend variables are set"
            echo "[INFO] .env file ready with $(wc -l < .env) configuration lines"
          fi
          EOF
          
          # Clean up temporary file
          rm -f /tmp/backend.env
          
          # Sync backend source code with optimizations and progress reporting
          echo "[SYNC] Syncing backend source code with optimizations..."
          echo "[INFO] Excluding build artifacts (bin/, obj/) and IDE files for faster transfer..."
          
          # Use rsync for faster sync with compression, delta transfer, and progress
          rsync -avz --compress-level=1 --progress \
                --exclude='bin/' --exclude='obj/' --exclude='*.log' --exclude='*.tmp' \
                --exclude='.vs/' --exclude='.vscode/' --exclude='node_modules/' \
                --exclude='TestResults/' --exclude='*.user' --exclude='*.suo' \
                -e "ssh -F $HOME/.ssh/config" \
                src/be/ truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/src/be/
          
          # Create logs directory structure in parallel with source sync completion
          echo "[SETUP] Creating logs directory structure..."
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10 -F "$HOME/.ssh/config" truenas-cf-tunnel "mkdir -p ${{ env.TRUENAS_DEPLOY_DIR }}/logs/{identity,corefinance,excel,ocelot}"
          
          echo "[SUCCESS] Files and source code synced to TrueNAS"

      - name: "[6/7] Deploy Backend APIs"
        timeout-minutes: 30
        run: |
          ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=10 -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
            cd ${{ env.TRUENAS_DEPLOY_DIR }}
            
            # Check Docker access
            if docker ps >/dev/null 2>&1; then
              USE_SUDO=""
            else
              USE_SUDO="sudo"
            fi
            
            echo "[INFO] Deploying Backend APIs..."
            echo "[INFO] Environment: ${{ env.ENVIRONMENT }}"
            echo "[INFO] Services: ${{ env.SERVICES_TO_DEPLOY }}"
            
            # TEMPORARILY: Always use docker-compose.services.yml (build from source) 
            # due to GHCR network timeout issues
            COMPOSE_FILE="docker-compose.services.yml"
            echo "[INFO] Using source code compose file: $COMPOSE_FILE"
            echo "[INFO] GHCR images temporarily disabled due to network timeout"
            
            # Parse and deploy services
            SERVICES_TO_DEPLOY="${{ env.SERVICES_TO_DEPLOY }}"
            echo "[DEBUG] Raw services string: '$SERVICES_TO_DEPLOY'"
            
            # Parse services using explicit list approach for shell compatibility  
            DEPLOYED_SERVICES=""
            FAILED_SERVICES=""
            
            echo "[DEBUG] Raw services string: '$SERVICES_TO_DEPLOY'"
            
            # TEMPORARILY DISABLED: Skip GHCR image pulls due to network timeout
            # Will build directly from source code via docker-compose.services.yml
            echo "[BUILD] Building services from source code instead of pulling GHCR images..."
            
            # Debug: List available services in compose file
            echo "[DEBUG] Available services in compose file:"
            $USE_SUDO docker compose -f $COMPOSE_FILE config --services
            
            # Create temporary file with services list
            TEMP_SERVICES_FILE="/tmp/services_list_$$"
            echo "$SERVICES_TO_DEPLOY" | tr ',' '\n' > "$TEMP_SERVICES_FILE"
            
            # Process each service from file
            while IFS= read -r service; do
              service=$(echo "$service" | xargs) # trim whitespace
              
              # Skip empty lines
              [ -z "$service" ] && continue
              
              echo "[DEPLOY] Deploying '$service'..."
              echo "[DEBUG] Service name length: ${#service}"
              
              if $USE_SUDO docker compose -f $COMPOSE_FILE config --services | grep -q "^$service$"; then
                # Build with optimized settings to prevent timeout
                echo "[BUILD] Building $service with optimized settings..."
                DOCKER_BUILDKIT=1 $USE_SUDO docker compose -f $COMPOSE_FILE build --no-cache --parallel $service || {
                  echo "[ERROR] Build failed for $service, trying without --no-cache..."
                  DOCKER_BUILDKIT=1 $USE_SUDO docker compose -f $COMPOSE_FILE build $service
                }
                
                # Start the service
                $USE_SUDO docker compose -f $COMPOSE_FILE up -d --no-deps --force-recreate $service
                
                # Enhanced health validation
                echo "[HEALTH] Performing comprehensive health validation for $service..."
                max_attempts=20
                attempt=1
                service_ready=false
                
                # Phase 1: Wait for container to be running
                echo "[PHASE 1/3] Waiting for container to start..."
                while [ $attempt -le 10 ]; do
                  if $USE_SUDO docker compose -f $COMPOSE_FILE ps $service | grep -q "Up"; then
                    echo "[RUNNING] $service container is running"
                    break
                  else
                    echo "[WAIT] Container not ready yet (attempt $attempt/10)"
                    sleep 10
                    ((attempt++))
                  fi
                done
                
                if [ $attempt -gt 10 ]; then
                  echo "[ERROR] $service container failed to start"
                  FAILED_SERVICES+=("$service")
                  continue
                fi
                
                # Phase 2: Wait for Docker healthcheck to pass
                echo "[PHASE 2/3] Waiting for Docker healthcheck to pass..."
                attempt=1
                while [ $attempt -le 15 ]; do
                  health_status=$($USE_SUDO docker compose -f $COMPOSE_FILE ps $service --format "table {{.Name}}\t{{.Status}}" | grep -v "NAME" | awk '{print $NF}' | sed 's/.*(\(.*\)).*/\1/' 2>/dev/null || echo "unknown")
                  echo "[HEALTH] $service healthcheck status: $health_status"
                  
                  if echo "$health_status" | grep -q "healthy"; then
                    echo "[HEALTHY] $service Docker healthcheck passed"
                    break
                  elif echo "$health_status" | grep -q "unhealthy"; then
                    echo "[UNHEALTHY] $service failed healthcheck"
                    echo "[DEBUG] Container logs:"
                    $USE_SUDO docker compose -f $COMPOSE_FILE logs --tail=20 $service
                    break
                  else
                    echo "[WAIT] Healthcheck still in progress (attempt $attempt/15)"
                    sleep 20
                    ((attempt++))
                  fi
                done
                
                # Phase 3: Additional API-specific validation
                echo "[PHASE 3/3] Performing API-specific validation..."
                if echo "$health_status" | grep -q "healthy" || [ $attempt -le 15 ]; then
                  case "$service" in
                    "identity-api")
                      echo "[VALIDATE] Testing Identity API endpoints..."
                      # Identity API uses /health not /identity/health
                      if $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service curl -f -s http://localhost:8080/health >/dev/null 2>&1; then
                        echo "[SUCCESS] Identity API health endpoint accessible"
                        # Optional: Test swagger endpoint
                        if $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service curl -f -s http://localhost:8080/swagger >/dev/null 2>&1; then
                          echo "[SUCCESS] Identity API swagger accessible"
                        fi
                        service_ready=true
                      else
                        echo "[FAILED] Identity API health endpoint failed"
                        echo "[DEBUG] Checking if service is listening on port 8080..."
                        $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service netstat -tlnp | grep :8080 || true
                      fi
                      ;;
                    "corefinance-api")
                      echo "[VALIDATE] Testing CoreFinance API endpoints..."
                      if $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service curl -f -s http://localhost:8080/health >/dev/null 2>&1; then
                        echo "[SUCCESS] CoreFinance API health endpoint accessible"
                        service_ready=true
                      else
                        echo "[FAILED] CoreFinance API health endpoint failed"
                        echo "[DEBUG] Checking if service is listening on port 8080..."
                        $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service netstat -tlnp | grep :8080 || true
                      fi
                      ;;
                    "excel-api")
                      echo "[VALIDATE] Testing Excel API endpoints..."
                      if $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service curl -f -s http://localhost:8080/health >/dev/null 2>&1; then
                        echo "[SUCCESS] Excel API health endpoint accessible"
                        service_ready=true
                      else
                        echo "[FAILED] Excel API health endpoint failed"
                        echo "[DEBUG] Checking if service is listening on port 8080..."
                        $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service netstat -tlnp | grep :8080 || true
                      fi
                      ;;
                    "ocelot-gateway")
                      echo "[VALIDATE] Testing API Gateway endpoints..."
                      if $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service curl -f -s http://localhost:8080/health >/dev/null 2>&1; then
                        echo "[SUCCESS] API Gateway health endpoint accessible"
                        service_ready=true
                      else
                        echo "[FAILED] API Gateway health endpoint failed"
                        echo "[DEBUG] Checking if service is listening on port 8080..."
                        $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service netstat -tlnp | grep :8080 || true
                      fi
                      ;;
                    *)
                      echo "[SUCCESS] Generic service validation passed"
                      service_ready=true
                      ;;
                  esac
                else
                  echo "[FAILED] Service healthcheck never became healthy"
                fi
                
                if [ "$service_ready" = true ]; then
                  DEPLOYED_SERVICES="$DEPLOYED_SERVICES $service"
                else
                  echo "[WARNING] $service deployment may need more time"
                  echo "[DEBUG] Recent logs for $service:"
                  $USE_SUDO docker compose -f $COMPOSE_FILE logs --tail=10 $service
                  FAILED_SERVICES="$FAILED_SERVICES $service"
                fi
              else
                echo "[ERROR] Service $service not found in compose file"
                FAILED_SERVICES="$FAILED_SERVICES $service"
              fi
            done < "$TEMP_SERVICES_FILE"
            
            # Clean up temporary file
            rm -f "$TEMP_SERVICES_FILE"
            
            # Deployment summary
            echo ""
            echo "[SUMMARY] Backend API Deployment Results:"
            echo "========================================="
            
            # Trim leading/trailing spaces
            DEPLOYED_SERVICES=$(echo "$DEPLOYED_SERVICES" | xargs)
            FAILED_SERVICES=$(echo "$FAILED_SERVICES" | xargs)
            
            if [ -n "$DEPLOYED_SERVICES" ]; then
              echo "✅ Successfully deployed:"
              for service in $DEPLOYED_SERVICES; do
                echo "   • $service"
              done
            fi
            
            if [ -n "$FAILED_SERVICES" ]; then
              echo "❌ Failed or needs attention:"
              for service in $FAILED_SERVICES; do
                echo "   • $service"
              done
            fi
            
            # Final comprehensive validation
            echo ""
            echo "[FINAL VALIDATION] Running comprehensive system validation..."
            
            # Check all deployed services are healthy
            all_healthy=true
            unhealthy_services=""
            
            for service in $DEPLOYED_SERVICES; do
              health_status=$($USE_SUDO docker compose -f $COMPOSE_FILE ps $service --format "table {{.Name}}\t{{.Status}}" | grep -v "NAME" | awk '{print $NF}' | sed 's/.*(\(.*\)).*/\1/' 2>/dev/null || echo "unknown")
              
              if ! echo "$health_status" | grep -q "healthy"; then
                all_healthy=false
                unhealthy_services="$unhealthy_services $service"
                echo "❌ $service is not healthy: $health_status"
              else
                echo "✅ $service is healthy"
              fi
            done
            
            # Test inter-service communication if gateway is deployed
            if echo " $DEPLOYED_SERVICES " | grep -q " ocelot-gateway "; then
              echo "[INTEGRATION] Testing API Gateway routing..."
              
              # Test gateway can reach identity service
              if echo " $DEPLOYED_SERVICES " | grep -q " identity-api "; then
                if $USE_SUDO docker compose -f $COMPOSE_FILE exec -T ocelot-gateway curl -f -s http://identity-api:8080/health >/dev/null 2>&1; then
                  echo "✅ Gateway -> Identity API communication working"
                else
                  echo "❌ Gateway -> Identity API communication failed"
                  all_healthy=false
                fi
              fi
              
              # Test gateway can reach corefinance service
              if echo " $DEPLOYED_SERVICES " | grep -q " corefinance-api "; then
                if $USE_SUDO docker compose -f $COMPOSE_FILE exec -T ocelot-gateway curl -f -s http://corefinance-api:8080/health >/dev/null 2>&1; then
                  echo "✅ Gateway -> CoreFinance API communication working"
                else
                  echo "❌ Gateway -> CoreFinance API communication failed"
                  all_healthy=false
                fi
              fi
            fi
            
            # Final validation summary
            echo ""
            echo "[VALIDATION SUMMARY]"
            echo "===================="
            
            # Trim spaces
            unhealthy_services=$(echo "$unhealthy_services" | xargs)
            
            if [ "$all_healthy" = true ] && [ -z "$FAILED_SERVICES" ]; then
              echo "🎉 ALL SERVICES ARE FULLY OPERATIONAL!"
              echo "✅ Container health: PASSED"
              echo "✅ API endpoints: PASSED"
              echo "✅ Service communication: PASSED"
              
              # Show service URLs for easy access
              echo ""
              echo "🔗 Service Access URLs:"
              if echo " $DEPLOYED_SERVICES " | grep -q " ocelot-gateway "; then
                echo "   • API Gateway: http://<TRUENAS_IP>:${{ vars.GATEWAY_PORT || '5800' }}"
              fi
              if echo " $DEPLOYED_SERVICES " | grep -q " identity-api "; then
                echo "   • Identity API: http://<TRUENAS_IP>:${{ vars.GATEWAY_PORT || '5800' }}/identity"
              fi
              if echo " $DEPLOYED_SERVICES " | grep -q " corefinance-api "; then
                echo "   • CoreFinance API: http://<TRUENAS_IP>:${{ vars.GATEWAY_PORT || '5800' }}/corefinance"
              fi
              
              exit 0
            else
              echo "❌ DEPLOYMENT ISSUES DETECTED!"
              if [ -n "$FAILED_SERVICES" ]; then
                echo "   Failed services: $FAILED_SERVICES"
              fi
              if [ -n "$unhealthy_services" ]; then
                echo "   Unhealthy services: $unhealthy_services"
              fi
              echo ""
              echo "📋 Troubleshooting steps:"
              echo "1. Check logs: docker compose -f $COMPOSE_FILE logs [service-name]"
              echo "2. Check service status: docker compose -f $COMPOSE_FILE ps"
              echo "3. Check environment variables: docker compose -f $COMPOSE_FILE config"
              echo "4. Restart unhealthy services: docker compose -f $COMPOSE_FILE restart [service-name]"
              
              exit 1
            fi
            
            # Final service status check
            echo ""
            echo "[STATUS] Final service status:"
            $USE_SUDO docker compose -f $COMPOSE_FILE ps
          EOF

      - name: "[7/7] Send notification"
        if: always()
        uses: appleboy/discord-action@v1.2.0
        with:
          webhook_url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          message: |
            ${{ job.status == 'success' && '🎉 **Backend APIs Deployment SUCCESSFUL & VALIDATED**' || '❌ **Backend APIs Deployment FAILED**' }}
            
            🔧 **Backend Deployment Info:**
            • **Environment:** `${{ env.ENVIRONMENT }}`
            • **Branch:** `${{ github.ref_name }}`
            • **Services:** `${{ env.SERVICES_TO_DEPLOY }}`
            • **Commit:** `${{ github.sha }}`
            
            ${{ job.status == 'success' && '✅ **Validation Results:**
            • ✅ Container Health: PASSED
            • ✅ API Endpoints: PASSED  
            • ✅ Service Communication: PASSED
            • 🔗 API Gateway: `http://<TRUENAS_IP>:' || '❌ **Validation Failed:**
            • Some services failed to start or pass health checks
            • Check logs: `docker compose logs [service-name]`
            • Troubleshoot: `docker compose ps`
            
            📋 **Next Steps:**' }}${{ vars.GATEWAY_PORT || '5800' }}${{ job.status == 'success' && '`

            🚀 **All APIs are fully operational and ready to serve requests!**' || '
            1. Review GitHub Actions logs for detailed error information
            2. SSH to server and check service status
            3. Restart failed services if needed**' }}