name: Deploy Backend APIs

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      services:
        description: 'Specific services to deploy (comma-separated: identity-api,corefinance-api,excel-api,ocelot-gateway) or "all"'
        required: false
        default: 'all'
        type: string
      force_rebuild:
        description: 'Force rebuild images'
        required: false
        default: false
        type: boolean
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'development'
        type: string
      services:
        description: 'Specific services to deploy (comma-separated: identity-api,corefinance-api,excel-api,ocelot-gateway) or "all"'
        required: false
        default: 'all'
        type: string
      force_rebuild:
        description: 'Force rebuild images'
        required: false
        default: false
        type: boolean

concurrency:
  group: tihomo-backend-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  # Build and test backend services
  build-and-test:
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      matrix:
        service: [identity-api, corefinance-api, excel-api, ocelot-gateway]
    
    steps:
      - name: "[1/8] Checkout code"
        uses: actions/checkout@v4

      - name: "[2/8] Setup .NET"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: '9.0.x'

      - name: "[3/8] Restore dependencies"
        run: |
          cd src/be
          # Clear any cached packages and restore
          dotnet clean
          dotnet restore --force --no-cache

      - name: "[4/8] Build solution"
        run: |
          cd src/be
          dotnet build --no-restore --configuration Release

      - name: "[5/8] Run tests"
        run: |
          cd src/be
          # Run tests for the specific service if test project exists
          case "${{ matrix.service }}" in
            identity-api)
              if [ -d "Identity.Tests" ]; then
                dotnet test Identity.Tests --no-build --configuration Release --verbosity normal
              else
                echo "No tests found for Identity service"
              fi
              ;;
            corefinance-api)
              if [ -d "CoreFinance.Tests" ]; then
                dotnet test CoreFinance.Tests --no-build --configuration Release --verbosity normal
              else
                echo "No tests found for CoreFinance service"
              fi
              ;;
            excel-api)
              if [ -d "ExcelApi.Tests" ]; then
                dotnet test ExcelApi.Tests --no-build --configuration Release --verbosity normal
              else
                echo "No tests found for ExcelApi service"
              fi
              ;;
            ocelot-gateway)
              if [ -d "Ocelot.Gateway.Tests" ]; then
                dotnet test Ocelot.Gateway.Tests --no-build --configuration Release --verbosity normal
              else
                echo "No tests found for Ocelot Gateway service"
              fi
              ;;
          esac

      # TEMPORARILY DISABLED: GHCR build/push due to network timeout issues
      # Will deploy using source code directly via docker-compose.services.yml
      - name: "[6/6] Verify Docker build locally (without push)"
        if: github.event_name != 'pull_request'
        run: |
          cd src/be
          echo "‚úÖ Skipping GHCR build/push due to network timeout"
          echo "‚úÖ Will deploy using docker-compose.services.yml with source code"
          echo "‚úÖ Service ${{ matrix.service }} build test completed successfully"

  # Deploy to TrueNAS
  deploy:
    if: github.event_name != 'pull_request' && (github.ref == 'refs/heads/master' || github.ref == 'refs/heads/develop' || github.event_name == 'workflow_dispatch')
    needs: build-and-test
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    timeout-minutes: 20

    steps:
      - name: "[1/6] Checkout code"
        uses: actions/checkout@v4

      - name: "[2/6] Setup environment variables"
        run: |
          CLEAN_ENV=$(echo "${{ inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
          echo "TRUENAS_DEPLOY_DIR=${{ vars.DEPLOY_PATH_ON_TRUENAS }}/deploy_${GITHUB_REF_NAME}" >> $GITHUB_ENV
          echo "COMPOSE_PROJECT_NAME=tihomo_${CLEAN_ENV}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${CLEAN_ENV}" >> $GITHUB_ENV
          
          # Parse services to deploy
          SERVICES="${{ inputs.services || 'all' }}"
          if [ "$SERVICES" = "all" ]; then
            SERVICES="identity-api,corefinance-api,excel-api,ocelot-gateway"
          fi
          echo "SERVICES_TO_DEPLOY=${SERVICES}" >> $GITHUB_ENV
          
          echo "[INFO] Deploy directory: ${{ vars.DEPLOY_PATH_ON_TRUENAS }}/deploy_${GITHUB_REF_NAME}"
          echo "[INFO] Project name: tihomo_${CLEAN_ENV}"
          echo "[INFO] Deploying Backend APIs: ${SERVICES}"

      - name: "[3/6] Setup SSH and Cloudflared"
        run: |
          sudo wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O /usr/local/bin/cloudflared
          sudo chmod +x /usr/local/bin/cloudflared
          
          mkdir -p "$HOME/.ssh"
          echo "Host truenas-cf-tunnel
            HostName ${{ secrets.TRUENAS_SSH_HOSTNAME_THROUGH_CLOUDFLARED }}
            ProxyCommand cloudflared access ssh --hostname %h
            User ${{ secrets.TRUENAS_USER }}
            StrictHostKeyChecking accept-new" > "$HOME/.ssh/config"
          chmod 600 "$HOME/.ssh/config"

      - name: "[4/7] Add SSH key"
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.TRUENAS_SSH_PRIVATE_KEY }}

      - name: "[5/7] Sync deployment files and source code to server"
        run: |
          echo "[SYNC] Syncing deployment files and backend source code to TrueNAS..."
          
          # Create remote directory
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel "mkdir -p ${{ env.TRUENAS_DEPLOY_DIR }}"
          
          # Copy docker-compose files
          scp -F "$HOME/.ssh/config" docker-compose.services.yml truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          
          # Copy .env.template if exists and create basic .env file
          if [ -f ".env.template" ]; then
            scp -F "$HOME/.ssh/config" .env.template truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          fi
          
          # Create comprehensive .env file using GitHub secrets and variables (following deploy-infrastructure-services pattern)
          echo "[ENV] Creating comprehensive .env file on server using GitHub secrets..."
          
          # Create environment variables script with secrets
          cat > /tmp/backend_env_vars.sh << 'SCRIPT_EOF'
          export COMPOSE_PROJECT_NAME="${{ env.COMPOSE_PROJECT_NAME }}"
          export ENVIRONMENT="${{ env.ENVIRONMENT }}"
          
          # Database passwords
          export POSTGRES_SUPER_PASSWORD="${{ secrets.POSTGRES_SUPER_PASSWORD }}"
          export IDENTITY_DB_PASSWORD="${{ secrets.IDENTITY_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}"
          export COREFINANCE_DB_PASSWORD="${{ secrets.COREFINANCE_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}"
          
          # Authentication & Security
          export JWT_SECRET_KEY="${{ secrets.JWT_SECRET_KEY }}"
          export JWT_ISSUER="${{ secrets.JWT_ISSUER || 'tihomo' }}"
          export JWT_AUDIENCE_IDENTITY_API="${{ secrets.JWT_AUDIENCE_IDENTITY_API || 'identity-api' }}"
          export JWT_AUDIENCE_COREFINANCE_API="${{ secrets.JWT_AUDIENCE_COREFINANCE_API || 'corefinance-api' }}"
          export JWT_AUDIENCE_OCELOT_GATEWAY="${{ secrets.JWT_AUDIENCE_OCELOT_GATEWAY || 'ocelot-gateway' }}"
          
          # OAuth Configuration
          export APP_PUBLIC_GOOGLE_CLIENT_ID="${{ secrets.APP_PUBLIC_GOOGLE_CLIENT_ID }}"
          export FACEBOOK_APP_ID="${{ secrets.FACEBOOK_APP_ID }}"
          export FACEBOOK_APP_SECRET="${{ secrets.FACEBOOK_APP_SECRET }}"
          
          # Infrastructure
          export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
          export RABBITMQ_PASSWORD="${{ secrets.RABBITMQ_PASSWORD }}"
          
          # Frontend Configuration
          export FRONTEND_BASE_URL="${{ vars.FRONTEND_BASE_URL || 'http://localhost:3500' }}"
          export PUBLIC_API_BASE_URL="${{ vars.PUBLIC_API_BASE_URL || 'http://localhost:5800' }}"
          
          # Ports from variables
          export FRONTEND_PORT="${{ vars.FRONTEND_PORT || '3500' }}"
          export GATEWAY_PORT="${{ vars.GATEWAY_PORT || '5800' }}"
          SCRIPT_EOF
          
          scp -F "$HOME/.ssh/config" /tmp/backend_env_vars.sh truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
          cd ${{ env.TRUENAS_DEPLOY_DIR }}
          
          # Load environment variables from secrets
          source ./backend_env_vars.sh
          
          echo "[CREATE] Creating comprehensive backend .env file..."
          
          # Create .env using echo statements to avoid YAML/HEREDOC conflicts (following infrastructure pattern)
          echo "# TiHoMo Backend Environment Configuration" > .env
          echo "# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> .env
          echo "" >> .env
          echo "# Project Configuration" >> .env
          echo "COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME}" >> .env
          echo "ENVIRONMENT=${ENVIRONMENT}" >> .env
          echo "" >> .env
          echo "# Application Ports" >> .env
          echo "FRONTEND_PORT=${FRONTEND_PORT}" >> .env
          echo "GATEWAY_PORT=${GATEWAY_PORT}" >> .env
          echo "" >> .env
          echo "# Authentication & Security" >> .env
          echo "JWT_SECRET_KEY='${JWT_SECRET_KEY}'" >> .env
          echo "JWT_ISSUER='${JWT_ISSUER}'" >> .env
          echo "JWT_AUDIENCE_IDENTITY_API='${JWT_AUDIENCE_IDENTITY_API}'" >> .env
          echo "JWT_AUDIENCE_COREFINANCE_API='${JWT_AUDIENCE_COREFINANCE_API}'" >> .env
          echo "JWT_AUDIENCE_OCELOT_GATEWAY='${JWT_AUDIENCE_OCELOT_GATEWAY}'" >> .env
          echo "" >> .env
          echo "# OAuth Configuration" >> .env
          echo "APP_PUBLIC_GOOGLE_CLIENT_ID='${APP_PUBLIC_GOOGLE_CLIENT_ID}'" >> .env
          echo "FACEBOOK_APP_ID='${FACEBOOK_APP_ID}'" >> .env
          echo "FACEBOOK_APP_SECRET='${FACEBOOK_APP_SECRET}'" >> .env
          echo "NUXT_PUBLIC_FACEBOOK_APP_ID='${FACEBOOK_APP_ID}'" >> .env
          echo "" >> .env
          echo "# Frontend Configuration" >> .env
          echo "FRONTEND_BASE_URL='${FRONTEND_BASE_URL}'" >> .env
          echo "PUBLIC_API_BASE_URL='${PUBLIC_API_BASE_URL}'" >> .env
          echo "" >> .env
          echo "# Infrastructure" >> .env
          echo "REDIS_PASSWORD='${REDIS_PASSWORD}'" >> .env
          echo "RABBITMQ_PASSWORD='${RABBITMQ_PASSWORD}'" >> .env
          echo "" >> .env
          echo "# Database Configuration" >> .env
          echo "POSTGRES_SUPER_PASSWORD='${POSTGRES_SUPER_PASSWORD}'" >> .env
          echo "IDENTITY_DB_PASSWORD='${IDENTITY_DB_PASSWORD}'" >> .env
          echo "COREFINANCE_DB_PASSWORD='${COREFINANCE_DB_PASSWORD}'" >> .env
          echo "" >> .env
          echo "# Deployment Information" >> .env
          echo "DEPLOY_BRANCH=${{ github.ref_name }}" >> .env
          echo "DEPLOY_COMMIT=${{ github.sha }}" >> .env
          echo "DEPLOY_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> .env
          
          echo "[SUCCESS] Comprehensive .env file created with GitHub secrets"
          echo "[VALIDATION] Checking critical backend variables..."
          
          # Validate critical variables
          critical_vars=("JWT_SECRET_KEY" "REDIS_PASSWORD" "RABBITMQ_PASSWORD")
          missing_vars=""
          
          for var in "${critical_vars[@]}"; do
            if ! grep -q "^${var}=" .env || [ "$(grep "^${var}=" .env | cut -d'=' -f2 | tr -d "'")" = "" ]; then
              missing_vars="$missing_vars $var"
            fi
          done
          
          if [ -n "$missing_vars" ]; then
            echo "[ERROR] Missing critical backend variables:$missing_vars"
            exit 1
          else
            echo "[OK] All critical backend variables are set"
          fi
          EOF
          
          # Sync entire backend source code (required for docker-compose.services.yml build)
          echo "[SYNC] Syncing backend source code..."
          scp -F "$HOME/.ssh/config" -r src/be truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/src/
          
          # Copy logs directory structure if needed
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel "mkdir -p ${{ env.TRUENAS_DEPLOY_DIR }}/logs/{identity,corefinance,excel,ocelot}"
          
          echo "[SUCCESS] Files and source code synced to TrueNAS"

      - name: "[6/7] Deploy Backend APIs"
        run: |
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
            cd ${{ env.TRUENAS_DEPLOY_DIR }}
            
            # Check Docker access
            if docker ps >/dev/null 2>&1; then
              USE_SUDO=""
            else
              USE_SUDO="sudo"
            fi
            
            echo "[INFO] Deploying Backend APIs..."
            echo "[INFO] Environment: ${{ env.ENVIRONMENT }}"
            echo "[INFO] Services: ${{ env.SERVICES_TO_DEPLOY }}"
            
            # TEMPORARILY: Always use docker-compose.services.yml (build from source) 
            # due to GHCR network timeout issues
            COMPOSE_FILE="docker-compose.services.yml"
            echo "[INFO] Using source code compose file: $COMPOSE_FILE"
            echo "[INFO] GHCR images temporarily disabled due to network timeout"
            
            # Parse and deploy services
            SERVICES_TO_DEPLOY="${{ env.SERVICES_TO_DEPLOY }}"
            echo "[DEBUG] Raw services string: '$SERVICES_TO_DEPLOY'"
            
            # Convert comma-separated string to array
            IFS=',' read -ra SERVICES <<< "$SERVICES_TO_DEPLOY"
            DEPLOYED_SERVICES=()
            FAILED_SERVICES=()
            
            echo "[DEBUG] Parsed services array: ${SERVICES[@]}"
            
            # TEMPORARILY DISABLED: Skip GHCR image pulls due to network timeout
            # Will build directly from source code via docker-compose.services.yml
            echo "[BUILD] Building services from source code instead of pulling GHCR images..."
            
            # Debug: List available services in compose file
            echo "[DEBUG] Available services in compose file:"
            $USE_SUDO docker compose -f $COMPOSE_FILE config --services
            
            # Deploy services one by one
            for service in "${SERVICES[@]}"; do
              service=$(echo "$service" | xargs) # trim whitespace
              echo "[DEPLOY] Deploying '$service'..."
              echo "[DEBUG] Service name length: ${#service}"
              echo "[DEBUG] Service name hex: $(echo -n "$service" | xxd)"
              
              if $USE_SUDO docker compose -f $COMPOSE_FILE config --services | grep -q "^$service$"; then
                $USE_SUDO docker compose -f $COMPOSE_FILE up -d --no-deps --force-recreate $service
                
                # Wait for service to be ready
                echo "[HEALTH] Waiting for $service to be ready..."
                max_attempts=10
                attempt=1
                service_ready=false
                
                while [ $attempt -le $max_attempts ]; do
                  if $USE_SUDO docker compose -f $COMPOSE_FILE ps $service | grep -q "Up"; then
                    echo "[RUNNING] $service container is running"
                    
                    # Additional health check for APIs
                    sleep 10
                    if $USE_SUDO docker compose -f $COMPOSE_FILE exec -T $service curl -f http://localhost:8080/health >/dev/null 2>&1; then
                      echo "[SUCCESS] $service health check passed"
                      service_ready=true
                      break
                    else
                      echo "[INFO] $service container running but health endpoint not ready yet"
                    fi
                  else
                    echo "[WAIT] $service not ready yet (attempt $attempt/$max_attempts)"
                  fi
                  
                  sleep 15
                  ((attempt++))
                done
                
                if [ "$service_ready" = true ]; then
                  DEPLOYED_SERVICES+=("$service")
                else
                  echo "[WARNING] $service deployment may need more time"
                  echo "[DEBUG] Recent logs for $service:"
                  $USE_SUDO docker compose -f $COMPOSE_FILE logs --tail=10 $service
                  FAILED_SERVICES+=("$service")
                fi
              else
                echo "[ERROR] Service $service not found in compose file"
                FAILED_SERVICES+=("$service")
              fi
            done
            
            # Deployment summary
            echo ""
            echo "[SUMMARY] Backend API Deployment Results:"
            echo "========================================="
            
            if [ ${#DEPLOYED_SERVICES[@]} -gt 0 ]; then
              echo "‚úÖ Successfully deployed:"
              for service in "${DEPLOYED_SERVICES[@]}"; do
                echo "   ‚Ä¢ $service"
              done
            fi
            
            if [ ${#FAILED_SERVICES[@]} -gt 0 ]; then
              echo "‚ùå Failed or needs attention:"
              for service in "${FAILED_SERVICES[@]}"; do
                echo "   ‚Ä¢ $service"
              done
            fi
            
            # Final service status check
            echo ""
            echo "[STATUS] Final service status:"
            $USE_SUDO docker compose -f $COMPOSE_FILE ps
          EOF

      - name: "[7/7] Send notification"
        if: always()
        uses: appleboy/discord-action@v1.2.0
        with:
          webhook_url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          message: |
            ${{ job.status == 'success' && '‚öôÔ∏è **Backend APIs Deployment SUCCESS**' || '‚ùå **Backend APIs Deployment FAILED**' }}
            
            üîß **Backend Info:**
            ‚Ä¢ **Environment:** `${{ env.ENVIRONMENT }}`
            ‚Ä¢ **Branch:** `${{ github.ref_name }}`
            ‚Ä¢ **Services:** `${{ env.SERVICES_TO_DEPLOY }}`
            ‚Ä¢ **Gateway:** `http://<TRUENAS_IP>:${{ vars.GATEWAY_PORT || '5800' }}`
            
            ${{ job.status == 'success' && 'üöÄ **APIs are ready to serve requests!**' || 'üö® **Check deployment logs for details**' }}