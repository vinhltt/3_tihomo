name: Deploy Infrastructure Services

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production
      force_rebuild:
        description: 'Force rebuild images'
        required: false
        default: false
        type: boolean
  workflow_call:
    inputs:
      environment:
        required: true
        type: string
      force_rebuild:
        required: false
        type: boolean
        default: false

concurrency:
  group: tihomo-infrastructure-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  deploy-infrastructure:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}
    timeout-minutes: 20
    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      
    steps:
      - name: "[1/8] Checkout code"
        uses: actions/checkout@v4

      - name: "[2/8] Setup environment variables"
        run: |
          # Clean project name - remove special characters and ensure lowercase
          CLEAN_ENV=$(echo "${{ inputs.environment }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
          echo "TRUENAS_DEPLOY_DIR=${{ vars.DEPLOY_PATH_ON_TRUENAS }}/deploy_${GITHUB_REF_NAME}" >> $GITHUB_ENV
          echo "COMPOSE_PROJECT_NAME=tihomo_${CLEAN_ENV}" >> $GITHUB_ENV
          echo "[INFO] Deploy directory: ${{ vars.DEPLOY_PATH_ON_TRUENAS }}/deploy_${GITHUB_REF_NAME}"
          echo "[INFO] Project name: tihomo_${CLEAN_ENV}"
          echo "[INFO] Environment input: '${{ inputs.environment }}' ‚Üí cleaned: '${CLEAN_ENV}'"
        shell: bash

      - name: "[3/8] Setup SSH and Cloudflared"
        run: |
          sudo wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O /usr/local/bin/cloudflared
          sudo chmod +x /usr/local/bin/cloudflared
          
          mkdir -p "$HOME/.ssh"
          echo "Host truenas-cf-tunnel
            HostName ${{ secrets.TRUENAS_SSH_HOSTNAME_THROUGH_CLOUDFLARED }}
            ProxyCommand cloudflared access ssh --hostname %h
            User ${{ secrets.TRUENAS_USER }}
            StrictHostKeyChecking accept-new
            ServerAliveInterval 60
            ConnectTimeout 30" > "$HOME/.ssh/config"
          chmod 600 "$HOME/.ssh/config"
        shell: bash

      - name: "[4/8] Add SSH key"
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.TRUENAS_SSH_PRIVATE_KEY }}

      - name: "[5/8] Prepare deployment directory and create environment file"
        run: |
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel << 'REMOTE_EOF'
            # Create deployment directory if it doesn't exist
            mkdir -p ${{ env.TRUENAS_DEPLOY_DIR }}
            cd ${{ env.TRUENAS_DEPLOY_DIR }}
            
            echo "[INFO] Working in directory: $(pwd)"
            echo "[INFO] Creating .env file..."
            
            cat > .env << 'EOF'
          # Project Configuration
          COMPOSE_PROJECT_NAME=${{ env.COMPOSE_PROJECT_NAME }}
          
          # Core Configuration
          GATEWAY_PORT=${{ vars.GATEWAY_PORT || '5000' }}
          FRONTEND_PORT=${{ vars.FRONTEND_PORT || '3500' }}
          FRONTEND_BASE_URL=${{ vars.FRONTEND_BASE_URL || 'http://localhost:3500' }}
          JWT_SECRET_KEY='${{ secrets.JWT_SECRET_KEY }}'
          
          # Docker Build Configuration
          NUXT_BUILD_TARGET=${{ vars.NUXT_BUILD_TARGET || 'production' }}
          NODE_ENV=${{ vars.NODE_ENV || 'production' }}
          DOCKER_USER=${{ vars.DOCKER_USER || '1001:1001' }}
          
          # Production-specific Nuxt settings
          NUXT_DEV_SSR=${{ vars.NUXT_DEV_SSR || 'false' }}
          NUXT_DEV_TOOLS=${{ vars.NUXT_DEV_TOOLS || 'false' }}
          NUXT_DEBUG=${{ vars.NUXT_DEBUG || 'false' }}
          
          # Database Configuration - Identity
          IDENTITY_DB_USERNAME=${{ secrets.IDENTITY_DB_USERNAME || 'identity_user' }}
          IDENTITY_DB_PASSWORD='${{ secrets.IDENTITY_DB_PASSWORD }}'
          IDENTITY_DB_PORT=${{ vars.IDENTITY_DB_PORT || '5831' }}
          
          # Database Configuration - CoreFinance
          COREFINANCE_DB_USERNAME=${{ secrets.COREFINANCE_DB_USERNAME || 'corefinance_user' }}
          COREFINANCE_DB_PASSWORD='${{ secrets.COREFINANCE_DB_PASSWORD }}'
          COREFINANCE_DB_PORT=${{ vars.COREFINANCE_DB_PORT || '5832' }}
          
          # Database Configuration - MoneyManagement
          MONEYMANAGEMENT_DB_USERNAME=${{ secrets.MONEYMANAGEMENT_DB_USERNAME || 'money_user' }}
          MONEYMANAGEMENT_DB_PASSWORD='${{ secrets.MONEYMANAGEMENT_DB_PASSWORD || secrets.IDENTITY_DB_PASSWORD }}'
          MONEYMANAGEMENT_DB_PORT=${{ vars.MONEYMANAGEMENT_DB_PORT || '5835' }}
          
          # Database Configuration - PlanningInvestment
          PLANNINGINVESTMENT_DB_USERNAME=${{ secrets.PLANNINGINVESTMENT_DB_USERNAME || 'planning_user' }}
          PLANNINGINVESTMENT_DB_PASSWORD='${{ secrets.PLANNINGINVESTMENT_DB_PASSWORD || secrets.IDENTITY_DB_PASSWORD }}'
          PLANNINGINVESTMENT_DB_PORT=${{ vars.PLANNINGINVESTMENT_DB_PORT || '5836' }}
          
          # Database Configuration - Reporting
          REPORTING_DB_USERNAME=${{ secrets.REPORTING_DB_USERNAME || 'reporting_user' }}
          REPORTING_DB_PASSWORD='${{ secrets.REPORTING_DB_PASSWORD || secrets.IDENTITY_DB_PASSWORD }}'
          REPORTING_DB_PORT=${{ vars.REPORTING_DB_PORT || '5837' }}
          
          # Redis Configuration
          REDIS_PORT=${{ vars.REDIS_PORT || '6379' }}
          REDIS_PASSWORD='${{ secrets.REDIS_PASSWORD }}'
          
          # RabbitMQ Configuration
          RABBITMQ_PORT=${{ vars.RABBITMQ_PORT || '5672' }}
          RABBITMQ_MANAGEMENT_PORT=${{ vars.RABBITMQ_MANAGEMENT_PORT || '15672' }}
          RABBITMQ_PASSWORD='${{ secrets.RABBITMQ_PASSWORD }}'
          
          # Monitoring Configuration
          PROMETHEUS_PORT=${{ vars.PROMETHEUS_PORT || '9090' }}
          GRAFANA_PORT=${{ vars.GRAFANA_PORT || '3002' }}
          GRAFANA_ADMIN_PASSWORD='${{ secrets.GRAFANA_ADMIN_PASSWORD || secrets.IDENTITY_DB_PASSWORD }}'
          LOKI_PORT=${{ vars.LOKI_PORT || '3100' }}
          
          # Development Tools
          PGADMIN_PORT=${{ vars.PGADMIN_PORT || '8081' }}
          PGADMIN_PASSWORD='${{ secrets.PGADMIN_PASSWORD || secrets.IDENTITY_DB_PASSWORD }}'
          MAILHOG_SMTP_PORT=${{ vars.MAILHOG_SMTP_PORT || '1025' }}
          MAILHOG_UI_PORT=${{ vars.MAILHOG_UI_PORT || '8025' }}
          
          # Nginx Configuration
          NGINX_HTTP_PORT=${{ vars.NGINX_HTTP_PORT || '8082' }}
          NGINX_HTTPS_PORT=${{ vars.NGINX_HTTPS_PORT || '8443' }}
          
          # Network Configuration
          DOCKER_NETWORK_SUBNET=${{ vars.DOCKER_NETWORK_SUBNET || '172.20.0.0/16' }}
          
          # Application Environment
          NODE_ENV=${{ vars.NODE_ENV || 'production' }}
          ASPNETCORE_ENVIRONMENT=${{ vars.ASPNETCORE_ENVIRONMENT || 'Production' }}
          
          # OAuth Configuration
          APP_PUBLIC_GOOGLE_CLIENT_ID=${{ secrets.APP_PUBLIC_GOOGLE_CLIENT_ID }}
          
          # JWT Configuration
          JWT_ISSUER=${{ vars.JWT_ISSUER || 'http://localhost:5000' }}
          JWT_AUDIENCE_OCELOT_GATEWAY=${{ vars.JWT_AUDIENCE_OCELOT_GATEWAY || 'TiHoMo.Gateway' }}
          JWT_AUDIENCE_IDENTITY_API=${{ vars.JWT_AUDIENCE_IDENTITY_API || 'TiHoMo.Identity' }}
          JWT_AUDIENCE_COREFINANCE_API=${{ vars.JWT_AUDIENCE_COREFINANCE_API || 'TiHoMo.CoreFinance' }}
          
          # Timezone & other settings
          GENERIC_TIMEZONE=${{ vars.GENERIC_TIMEZONE || 'Asia/Ho_Chi_Minh' }}
          TZ=${{ vars.TZ || 'Asia/Ho_Chi_Minh' }}
          
          # Build Configuration
          NUXT_BUILD_TARGET=production
          NUXT_DEV_SSR=${{ vars.NUXT_DEV_SSR || 'false' }}
          NUXT_DEBUG=${{ vars.NUXT_DEBUG || 'false' }}
          NUXT_DEV_TOOLS=${{ vars.NUXT_DEV_TOOLS || 'false' }}
          NUXT_TELEMETRY_DISABLED=1
          
          # Logging Configuration
          LOG_LEVEL=${{ vars.LOG_LEVEL || 'info' }}
          LOG_FORMAT=${{ vars.LOG_FORMAT || 'json' }}
          
          # Feature Toggles
          ENABLE_PWA=${{ vars.ENABLE_PWA || 'false' }}
          ENABLE_ANALYTICS=${{ vars.ENABLE_ANALYTICS || 'false' }}
          
          # Deployment Information
          DEPLOY_BRANCH=${{ github.ref_name }}
          DEPLOY_COMMIT=${{ github.sha }}
          DEPLOY_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          EOF
          
          echo "[SUCCESS] .env file created successfully"
          echo "[INFO] File contents:"
          head -10 .env
          
          echo "[DEBUG] Network configuration:"
          grep DOCKER_NETWORK_SUBNET .env || echo "DOCKER_NETWORK_SUBNET not found in .env"
          
          # Validate CIDR format
          SUBNET=$(grep DOCKER_NETWORK_SUBNET .env | cut -d'=' -f2)
          echo "[DEBUG] Subnet value: '$SUBNET'"
          
          if [[ "$SUBNET" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
            echo "[OK] Subnet format is valid"
          else
            echo "[ERROR] Invalid subnet format: '$SUBNET'"
            echo "[FIX] Setting default subnet..."
            sed -i 's/^DOCKER_NETWORK_SUBNET=.*/DOCKER_NETWORK_SUBNET=172.20.0.0\/16/' .env
          fi
          
          echo "[VALIDATION] Checking critical environment variables..."
          
          # Check for empty/missing critical variables
          CRITICAL_VARS=("JWT_SECRET_KEY" "REDIS_PASSWORD" "RABBITMQ_PASSWORD")
          MISSING_VARS=()
          
          for var in "${CRITICAL_VARS[@]}"; do
            if ! grep -q "^${var}=" .env || [ "$(grep "^${var}=" .env | cut -d'=' -f2 | tr -d "'")" = "" ]; then
              MISSING_VARS+=("$var")
            fi
          done
          
          if [ ${#MISSING_VARS[@]} -gt 0 ]; then
            echo "[WARNING] Missing or empty critical variables: ${MISSING_VARS[*]}"
            echo "[WARNING] This may cause service startup failures"
          else
            echo "[OK] All critical variables are set"
          fi
          
          echo "[INFO] Environment variables summary:"
          echo "  - Total variables: $(wc -l < .env)"
          echo "  - Network subnet: $(grep DOCKER_NETWORK_SUBNET .env | cut -d'=' -f2)"
          echo "  - Project name: $(grep COMPOSE_PROJECT_NAME .env | cut -d'=' -f2)"
          REMOTE_EOF
        shell: bash

      - name: "[6/8] Deploy infrastructure services"
        id: deploy
        run: |
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
            set -e
            cd ${{ env.TRUENAS_DEPLOY_DIR }}
            
            # Load environment
            source .env
            
            # Check Docker access
            if docker ps >/dev/null 2>&1; then
              USE_SUDO=""
            else
              USE_SUDO="sudo"
            fi
            
            echo "[INFRASTRUCTURE] Deploying infrastructure services..."
            
            # Clean up any existing networks with issues
            echo "[CLEANUP] Cleaning up potential network conflicts..."
            $USE_SUDO docker network ls --format "{{.Name}}" | grep "tihomo.*network" | while read network; do
              echo "[CLEANUP] Removing network: $network"
              $USE_SUDO docker network rm "$network" 2>/dev/null || true
            done
            
            # Infrastructure services in order
            SERVICES=("identity-postgres" "corefinance-postgres" "moneymanagement-postgres" "planninginvestment-postgres" "reporting-postgres" "redis" "rabbitmq")
            
            for service in "${SERVICES[@]}"; do
              echo "[DEPLOY] Deploying $service..."
              
              # Check if service exists
              if ! $USE_SUDO docker compose config --services | grep -q "^$service$"; then
                echo "[SKIP] Service $service not found in compose file"
                continue
              fi
              
              # Deploy service
              $USE_SUDO docker compose up -d --no-deps --force-recreate $service
              
              # Wait for service to be ready
              max_attempts=10
              attempt=1
              while [ $attempt -le $max_attempts ]; do
                if $USE_SUDO docker compose ps $service | grep -q "Up"; then
                  echo "[OK] Service $service is running"
                  break
                else
                  echo "[WAIT] Service $service not ready yet (attempt $attempt/$max_attempts)"
                  sleep 10
                  ((attempt++))
                fi
              done
              
              if [ $attempt -gt $max_attempts ]; then
                echo "[ERROR] Service $service failed to start"
                $USE_SUDO docker compose logs --tail=20 $service
                exit 1
              fi
              
              # Service-specific health checks
              case $service in
                *-postgres)
                  echo "[HEALTH] Checking database connectivity for $service..."
                  sleep 20  # Extra time for DB initialization
                  ;;
                redis)
                  echo "[HEALTH] Checking Redis connectivity..."
                  sleep 5
                  # Try with password authentication
                  if $USE_SUDO docker compose exec -T redis redis-cli -a "$REDIS_PASSWORD" ping | grep -q "PONG"; then
                    echo "[OK] Redis health check passed with auth"
                  elif $USE_SUDO docker compose exec -T redis redis-cli ping | grep -q "PONG"; then
                    echo "[OK] Redis health check passed without auth"
                  else
                    echo "[WARNING] Redis health check failed, but container is running"
                    echo "[DEBUG] Redis logs:"
                    $USE_SUDO docker compose logs --tail=10 redis
                    # Don't exit - continue with deployment
                  fi
                  ;;
                rabbitmq)
                  echo "[HEALTH] Checking RabbitMQ connectivity..."
                  sleep 10
                  $USE_SUDO docker compose exec -T rabbitmq rabbitmq-diagnostics ping || {
                    echo "[ERROR] RabbitMQ health check failed"
                    exit 1
                  }
                  ;;
              esac
            done
            
            echo "[SUCCESS] All infrastructure services deployed successfully"
            echo "status=success" >> $GITHUB_OUTPUT
          EOF
        shell: bash

      - name: "[7/8] Health check infrastructure"
        run: |
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
            cd ${{ env.TRUENAS_DEPLOY_DIR }}
            
            # Check Docker access
            if docker ps >/dev/null 2>&1; then
              USE_SUDO=""
            else
              USE_SUDO="sudo"
            fi
            
            echo "[HEALTH] Comprehensive infrastructure health check..."
            
            # Check all databases
            DATABASES=("identity-postgres" "corefinance-postgres" "moneymanagement-postgres" "planninginvestment-postgres" "reporting-postgres")
            for db in "${DATABASES[@]}"; do
              if $USE_SUDO docker compose ps $db | grep -q "Up"; then
                echo "[CHECK] $db is running"
              else
                echo "[ERROR] $db is not running"
                exit 1
              fi
            done
            
            # Check Redis
            if $USE_SUDO docker compose ps redis | grep -q "Up"; then
              $USE_SUDO docker compose exec -T redis redis-cli ping | grep -q "PONG" && echo "[OK] Redis is healthy"
            fi
            
            # Check RabbitMQ
            if $USE_SUDO docker compose ps rabbitmq | grep -q "Up"; then
              $USE_SUDO docker compose exec -T rabbitmq rabbitmq-diagnostics ping >/dev/null && echo "[OK] RabbitMQ is healthy"
            fi
            
            echo "[SUCCESS] Infrastructure health check passed"
          EOF
        shell: bash

      - name: "[8/8] Send notification"
        if: always()
        uses: appleboy/discord-action@v1.2.0
        with:
          webhook_url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          message: |
            ${{ job.status == 'success' && '‚úÖ **Infrastructure Deployment SUCCESS**' || '‚ùå **Infrastructure Deployment FAILED**' }}
            
            üìä **Deployment Info:**
            ‚Ä¢ **Environment:** `${{ inputs.environment }}`
            ‚Ä¢ **Branch:** `${{ github.ref_name }}`
            ‚Ä¢ **Services:** PostgreSQL Cluster, Redis, RabbitMQ
            ‚Ä¢ **Status:** `${{ job.status }}`
            
            ${{ job.status == 'success' && 'üîã **Infrastructure ready for application deployment**' || 'üö® **Infrastructure issues - check logs**' }}