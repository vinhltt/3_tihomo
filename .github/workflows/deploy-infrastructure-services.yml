name: Deploy Infrastructure Services

on:
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'development'
        type: choice
        options:
          - development
          - staging
          - production

      force_recreate_env:
        description: 'Force recreate .env file'
        required: false
        default: false
        type: boolean
  workflow_call:
    inputs:
      environment:
        description: 'Deployment environment'
        required: false
        default: 'development'
        type: string
      force_recreate_env:
        description: 'Force recreate .env file'
        required: false
        default: false
        type: boolean

concurrency:
  group: tihomo-infrastructure-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  # Deploy infrastructure services
  deploy-infrastructure:
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}
    timeout-minutes: 25
    outputs:
      deployment-status: ${{ steps.deploy.outputs.status }}
      
    steps:
      - name: "[1/10] Checkout code"
        uses: actions/checkout@v4

      - name: "[2/10] Setup environment variables"
        run: |
          CLEAN_ENV=$(echo "${{ inputs.environment || (github.ref == 'refs/heads/master' && 'production' || 'development') }}" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]//g')
          echo "TRUENAS_DEPLOY_DIR=${{ vars.DEPLOY_PATH_ON_TRUENAS }}/deploy_${GITHUB_REF_NAME}" >> $GITHUB_ENV
          echo "COMPOSE_PROJECT_NAME=tihomo_${CLEAN_ENV}" >> $GITHUB_ENV
          echo "ENVIRONMENT=${CLEAN_ENV}" >> $GITHUB_ENV
          
          echo "[INFO] Deploy directory: ${{ vars.DEPLOY_PATH_ON_TRUENAS }}/deploy_${GITHUB_REF_NAME}"
          echo "[INFO] Project name: tihomo_${CLEAN_ENV}"
          echo "[INFO] Deploying all infrastructure services"

      - name: "[3/10] Setup SSH and Cloudflared"
        run: |
          sudo wget -q https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64 -O /usr/local/bin/cloudflared
          sudo chmod +x /usr/local/bin/cloudflared
          
          mkdir -p "$HOME/.ssh"
          echo "Host truenas-cf-tunnel
            HostName ${{ secrets.TRUENAS_SSH_HOSTNAME_THROUGH_CLOUDFLARED }}
            ProxyCommand cloudflared access ssh --hostname %h
            User ${{ secrets.TRUENAS_USER }}
            StrictHostKeyChecking accept-new" > "$HOME/.ssh/config"
          chmod 600 "$HOME/.ssh/config"

      - name: "[4/10] Add SSH key"
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.TRUENAS_SSH_PRIVATE_KEY }}

      - name: "[5/10] Sync deployment files to TrueNAS"
        run: |
          echo "[SYNC] Syncing deployment files to TrueNAS..."
          
          # Create remote directory
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel "mkdir -p ${{ env.TRUENAS_DEPLOY_DIR }}"
          
          # Copy necessary files
          scp -F "$HOME/.ssh/config" docker-compose.infras.yml truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          
          # Copy config directory if exists
          if [ -d "config" ]; then
            scp -F "$HOME/.ssh/config" -r config truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          fi
          
          # Copy scripts directory if exists  
          if [ -d "scripts" ]; then
            scp -F "$HOME/.ssh/config" -r scripts truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          fi
          
          # Copy Makefile if exists
          if [ -f "Makefile" ]; then
            scp -F "$HOME/.ssh/config" Makefile truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          fi
          
          echo "[SUCCESS] Files synced to TrueNAS"

      - name: "[6/10] Create and validate environment file"
        run: |
          cat > /tmp/env_vars.sh << 'SCRIPT_EOF'
          export COMPOSE_PROJECT_NAME="${{ env.COMPOSE_PROJECT_NAME }}"
          export ENVIRONMENT="${{ env.ENVIRONMENT }}"
          export POSTGRES_SUPER_PASSWORD="${{ secrets.POSTGRES_SUPER_PASSWORD }}"
          export IDENTITY_DB_PASSWORD="${{ secrets.IDENTITY_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}"
          export COREFINANCE_DB_PASSWORD="${{ secrets.COREFINANCE_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}"
          export MONEYMANAGEMENT_DB_PASSWORD="${{ secrets.MONEYMANAGEMENT_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}"
          export PLANNINGINVESTMENT_DB_PASSWORD="${{ secrets.PLANNINGINVESTMENT_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}"
          export REPORTING_DB_PASSWORD="${{ secrets.REPORTING_DB_PASSWORD || secrets.POSTGRES_SUPER_PASSWORD }}"
          export REDIS_PASSWORD="${{ secrets.REDIS_PASSWORD }}"
          export RABBITMQ_PASSWORD="${{ secrets.RABBITMQ_PASSWORD }}"
          export GRAFANA_ADMIN_PASSWORD="${{ secrets.GRAFANA_ADMIN_PASSWORD }}"
          export PGADMIN_PASSWORD="${{ secrets.PGADMIN_PASSWORD }}"
          SCRIPT_EOF
          
          scp -F "$HOME/.ssh/config" /tmp/env_vars.sh truenas-cf-tunnel:${{ env.TRUENAS_DEPLOY_DIR }}/
          
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
            # Create deployment directory if it doesn't exist
            mkdir -p ${{ env.TRUENAS_DEPLOY_DIR }}
            cd ${{ env.TRUENAS_DEPLOY_DIR }}
            
            # Load environment variables
            source ./env_vars.sh
            
            echo "[INFO] Working in directory: $(pwd)"
            
            # Handle .env file creation/recreation
            if [ "${{ inputs.force_recreate_env }}" = "true" ]; then
              echo "[FORCE] Force recreate .env requested"
              if [ -f .env ]; then
                cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
                echo "[BACKUP] Created backup before force recreate"
              fi
              rm -f .env
            elif [ -f .env ]; then
              echo "[CHECK] .env file exists, validating required variables..."
              required_vars="COMPOSE_PROJECT_NAME POSTGRES_SUPER_PASSWORD REDIS_PASSWORD RABBITMQ_PASSWORD GRAFANA_ADMIN_PASSWORD"
              missing_vars=""
              
              for var in $required_vars; do
                if ! grep -q "^${var}=" .env; then
                  missing_vars="$missing_vars $var"
                fi
              done
              
              if [ -z "$missing_vars" ]; then
                echo "[OK] Existing .env file is valid"
                exit 0
              else
                echo "[WARNING] Missing variables: $missing_vars, recreating .env"
                cp .env .env.backup.$(date +%Y%m%d_%H%M%S)
                rm -f .env
              fi
            fi
            
            echo "[CREATE] Creating comprehensive .env file..."
            
            # Create .env using echo statements to avoid YAML/HEREDOC conflicts
            echo "# TiHoMo Infrastructure Environment Configuration" > .env
            echo "# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> .env
            echo "" >> .env
            echo "# Project Configuration" >> .env
            echo "COMPOSE_PROJECT_NAME=${COMPOSE_PROJECT_NAME}" >> .env
            echo "" >> .env
            echo "# Core Infrastructure Ports" >> .env
            echo "POSTGRES_PORT=${{ vars.POSTGRES_PORT || '5432' }}" >> .env
            echo "REDIS_PORT=${{ vars.REDIS_PORT || '6379' }}" >> .env
            echo "RABBITMQ_PORT=${{ vars.RABBITMQ_PORT || '5672' }}" >> .env
            echo "RABBITMQ_MANAGEMENT_PORT=${{ vars.RABBITMQ_MANAGEMENT_PORT || '15672' }}" >> .env

            echo "" >> .env
            echo "# Monitoring Ports" >> .env
            echo "PROMETHEUS_PORT=${{ vars.PROMETHEUS_PORT || '9090' }}" >> .env
            echo "GRAFANA_PORT=${{ vars.GRAFANA_PORT || '3000' }}" >> .env
            echo "LOKI_PORT=${{ vars.LOKI_PORT || '3100' }}" >> .env
            echo "" >> .env
            echo "# Development Tools Ports" >> .env
            echo "PGADMIN_PORT=${{ vars.PGADMIN_PORT || '8080' }}" >> .env
            echo "MAILHOG_SMTP_PORT=${{ vars.MAILHOG_SMTP_PORT || '1025' }}" >> .env
            echo "MAILHOG_UI_PORT=${{ vars.MAILHOG_UI_PORT || '8025' }}" >> .env
            echo "NGINX_HTTP_PORT=${{ vars.NGINX_HTTP_PORT || '80' }}" >> .env
            echo "NGINX_HTTPS_PORT=${{ vars.NGINX_HTTPS_PORT || '443' }}" >> .env
            echo "" >> .env
            echo "# Database Configuration" >> .env
            echo "POSTGRES_SUPER_USER=${{ vars.POSTGRES_SUPER_USER || 'postgres' }}" >> .env
            echo "POSTGRES_SUPER_PASSWORD='${POSTGRES_SUPER_PASSWORD}'" >> .env
            echo "IDENTITY_DB_PASSWORD='${IDENTITY_DB_PASSWORD}'" >> .env
            echo "COREFINANCE_DB_PASSWORD='${COREFINANCE_DB_PASSWORD}'" >> .env
            echo "MONEYMANAGEMENT_DB_PASSWORD='${MONEYMANAGEMENT_DB_PASSWORD}'" >> .env
            echo "PLANNINGINVESTMENT_DB_PASSWORD='${PLANNINGINVESTMENT_DB_PASSWORD}'" >> .env
            echo "REPORTING_DB_PASSWORD='${REPORTING_DB_PASSWORD}'" >> .env
            echo "" >> .env
            echo "# Redis Configuration" >> .env
            echo "REDIS_PASSWORD='${REDIS_PASSWORD}'" >> .env
            echo "REDIS_PERSISTENCE_CONFIG=$([ "${ENVIRONMENT}" = "production" ] && echo '--save 900 1 --save 300 10 --save 60 10000' || echo '')" >> .env
            echo "" >> .env
            echo "# RabbitMQ Configuration" >> .env
            echo "RABBITMQ_PASSWORD='${RABBITMQ_PASSWORD}'" >> .env
            echo "" >> .env
            echo "# Monitoring Configuration" >> .env
            echo "PROMETHEUS_RETENTION=$([ "${ENVIRONMENT}" = "production" ] && echo '30d' || echo '200h')" >> .env
            echo "GRAFANA_ADMIN_PASSWORD='${GRAFANA_ADMIN_PASSWORD}'" >> .env
            echo "GRAFANA_ANALYTICS_ENABLED=$([ "${ENVIRONMENT}" = "production" ] && echo 'false' || echo 'true')" >> .env
            echo "GRAFANA_CHECK_UPDATES=$([ "${ENVIRONMENT}" = "production" ] && echo 'false' || echo 'true')" >> .env
            echo "" >> .env
            echo "# Development Tools Configuration" >> .env
            echo "PGADMIN_PASSWORD='${PGADMIN_PASSWORD}'" >> .env
            echo "ENABLE_DEV_TOOLS=$([ "${ENVIRONMENT}" = "production" ] && echo 'none' || echo 'development')" >> .env
            echo "" >> .env
            echo "# OpenTelemetry Configuration" >> .env
            echo "OTEL_EXPORTER_OTLP_ENDPOINT=http://tempo:4317" >> .env
            echo "" >> .env
            echo "# Deployment Information" >> .env
            echo "DEPLOY_BRANCH=${{ github.ref_name }}" >> .env
            echo "DEPLOY_COMMIT=${{ github.sha }}" >> .env
            echo "DEPLOY_TIME=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> .env
            echo "ENVIRONMENT=${ENVIRONMENT}" >> .env
            
            echo "[SUCCESS] .env file created successfully"
            echo "[VALIDATION] Checking critical variables..."
            
            critical_vars=("POSTGRES_SUPER_PASSWORD" "REDIS_PASSWORD" "RABBITMQ_PASSWORD" "GRAFANA_ADMIN_PASSWORD")
            missing_vars=""
            
            for var in "${critical_vars[@]}"; do
              if ! grep -q "^${var}=" .env || [ "$(grep "^${var}=" .env | cut -d'=' -f2 | tr -d "'")" = "" ]; then
                missing_vars="$missing_vars $var"
              fi
            done
            
            if [ -n "$missing_vars" ]; then
              echo "[ERROR] Missing critical variables:$missing_vars"
              exit 1
            else
              echo "[OK] All critical variables are set"
            fi
          EOF

      - name: "[7/10] Deploy infrastructure services"
        id: deploy
        run: |
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
            cd ${{ env.TRUENAS_DEPLOY_DIR }}
            
            # Check Docker access and set command prefix
            echo "[DEBUG] Checking Docker access..."
            if docker ps >/dev/null 2>&1; then
              echo "[INFO] Docker accessible without sudo"
              USE_SUDO=""
            elif sudo -n docker ps >/dev/null 2>&1; then
              echo "[INFO] Docker accessible with sudo"
              USE_SUDO="sudo"
            else
              echo "[WARNING] Cannot verify Docker access. Trying without sudo..."
              USE_SUDO=""
            fi
            
            # Function to run docker commands with or without sudo
            run_docker() {
              if [ -z "$USE_SUDO" ]; then
                docker "$@"
              else
                sudo docker "$@"
              fi
            }
            
            echo "[INFO] Deploying infrastructure services..."
            echo "[INFO] Environment: ${{ env.ENVIRONMENT }}"
            echo "[INFO] Deploying all services from docker-compose.infras.yml"
            
            echo "[DEPLOY] Stopping existing infrastructure services..."
            run_docker compose -f docker-compose.infras.yml down --remove-orphans
            
            echo "[DEPLOY] Starting all infrastructure services..."
            run_docker compose -f docker-compose.infras.yml up -d
            
            echo "[WAIT] Waiting for services to stabilize..."
            sleep 30
            
            echo "[STATUS] Final infrastructure status:"
            run_docker compose -f docker-compose.infras.yml ps
            
            echo "[SUCCESS] All infrastructure services deployed!"
          EOF

      - name: "[8/10] Infrastructure health check"
        if: always()
        run: |
          # Health check for all services
          
          ssh -F "$HOME/.ssh/config" truenas-cf-tunnel << 'EOF'
            cd ${{ env.TRUENAS_DEPLOY_DIR }}
            
            # Check Docker access and set command prefix
            echo "[DEBUG] Checking Docker access..."
            if docker ps >/dev/null 2>&1; then
              echo "[INFO] Docker accessible without sudo"
              USE_SUDO=""
            elif sudo -n docker ps >/dev/null 2>&1; then
              echo "[INFO] Docker accessible with sudo"
              USE_SUDO="sudo"
            else
              echo "[WARNING] Cannot verify Docker access. Trying without sudo..."
              USE_SUDO=""
            fi
            
            # Function to run docker commands with or without sudo
            run_docker() {
              if [ -z "$USE_SUDO" ]; then
                docker "$@"
              else
                sudo docker "$@"
              fi
            }
            
            echo "[HEALTH] Comprehensive infrastructure health check..."
            
            # Check network
            if run_docker network inspect tihomo-network >/dev/null 2>&1; then
              echo "[OK] Network tihomo-network exists"
            else
              echo "[WARNING] Network tihomo-network not found"
            fi
            
            # Simple health check for all services
            echo "[HEALTH] Checking all infrastructure services..."
            run_docker compose -f docker-compose.infras.yml ps
            
            # Count running services
            RUNNING_COUNT=$(run_docker compose -f docker-compose.infras.yml ps --status running | wc -l)
            TOTAL_COUNT=$(run_docker compose -f docker-compose.infras.yml config --services | wc -l)
            
            echo "[HEALTH] Running services: $RUNNING_COUNT/$TOTAL_COUNT"
            
            if [ "$RUNNING_COUNT" -eq "$TOTAL_COUNT" ]; then
              echo "‚úÖ All infrastructure services are running"
            else
              echo "‚ö†Ô∏è  Some services may not be running - check logs above"
            fi
            
            echo "[INFO] Infrastructure deployment completed"
          EOF

      - name: "[9/10] Send notification"
        if: always()
        uses: appleboy/discord-action@v1.2.0
        with:
          webhook_url: ${{ secrets.DISCORD_WEBHOOK_URL }}
          message: |
            ${{ job.status == 'success' && 'üèóÔ∏è **Infrastructure Deployment SUCCESS**' || '‚ùå **Infrastructure Deployment FAILED**' }}
            
            üîß **Infrastructure Info:**
            ‚Ä¢ **Environment:** `${{ env.ENVIRONMENT }}`
            ‚Ä¢ **Branch:** `${{ github.ref_name }}`
            ‚Ä¢ **Services:** `All infrastructure services`
            ‚Ä¢ **Database:** `${{ vars.POSTGRES_PORT || '5432' }}`
            ‚Ä¢ **Monitoring:** `${{ vars.GRAFANA_PORT || '3000' }}`
            
            ${{ job.status == 'success' && '‚ö° **Infrastructure ready for applications!**' || 'üö® **Check deployment logs for details**' }}